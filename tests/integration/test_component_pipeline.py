"""
Integration tests for the component pipeline.
"""

import unittest
import numpy as np

from memoryweave.components.memory_manager import MemoryManager
from memoryweave.components.query_analysis import QueryAnalyzer
from memoryweave.components.personal_attributes import PersonalAttributeManager
from memoryweave.components.retrieval_strategies import (
    SimilarityRetrievalStrategy,
    TemporalRetrievalStrategy,
    HybridRetrievalStrategy,
)
from memoryweave.components.post_processors import (
    KeywordBoostProcessor,
    SemanticCoherenceProcessor,
    AdaptiveKProcessor,
)
from tests.utils.mock_models import MockMemory, MockEmbeddingModel


class ComponentPipelineTest(unittest.TestCase):
    """Integration tests for the component pipeline."""

    def setUp(self):
        """Set up test environment before each test."""
        # Create mock memory and embedding model
        self.memory = MockMemory(embedding_dim=768)
        self.embedding_model = MockEmbeddingModel(embedding_dim=768)
        
        # Populate memory with test data
        self._populate_test_memory()
        
        # Create memory manager
        self.memory_manager = MemoryManager()
        
        # Register components
        self.query_analyzer = QueryAnalyzer()
        self.memory_manager.register_component("query_analyzer", self.query_analyzer)
        
        self.personal_attributes = PersonalAttributeManager()
        self.memory_manager.register_component("personal_attributes", self.personal_attributes)
        
        self.similarity_retrieval = SimilarityRetrievalStrategy(self.memory)
        self.memory_manager.register_component("similarity_retrieval", self.similarity_retrieval)
        
        self.temporal_retrieval = TemporalRetrievalStrategy(self.memory)
        self.memory_manager.register_component("temporal_retrieval", self.temporal_retrieval)
        
        self.hybrid_retrieval = HybridRetrievalStrategy(self.memory)
        self.memory_manager.register_component("hybrid_retrieval", self.hybrid_retrieval)
        
        self.keyword_boost = KeywordBoostProcessor()
        self.memory_manager.register_component("keyword_boost", self.keyword_boost)
        
        self.coherence_check = SemanticCoherenceProcessor()
        self.memory_manager.register_component("coherence_check", self.coherence_check)
        
        self.adaptive_k = AdaptiveKProcessor()
        self.memory_manager.register_component("adaptive_k", self.adaptive_k)
        
    def _populate_test_memory(self):
        """Populate memory with test data."""
        # Add factual memories
        self._add_factual_memory(
            "Python is a high-level programming language known for its readability.",
            {"language": "Python", "type": "programming_language"}
        )
        self._add_factual_memory(
            "JavaScript is a scripting language used for web development.",
            {"language": "JavaScript", "type": "programming_language"}
        )
        
        # Add personal memories
        self._add_personal_memory(
            "My favorite color is blue.",
            {"preferences": {"color": "blue"}}
        )
        self._add_personal_memory(
            "I live in Seattle.",
            {"demographics": {"location": "Seattle"}}
        )
        
    def _add_factual_memory(self, content, metadata=None):
        """Add a factual memory to the test memory."""
        if metadata is None:
            metadata = {}
        
        metadata["type"] = "factual"
        metadata["content"] = content
        
        embedding = self.embedding_model.encode(content)
        self.memory.add_memory(embedding, content, metadata)
        
    def _add_personal_memory(self, content, metadata=None):
        """Add a personal memory to the test memory."""
        if metadata is None:
            metadata = {}
        
        metadata["type"] = "personal"
        metadata["content"] = content
        
        embedding = self.embedding_model.encode(content)
        self.memory.add_memory(embedding, content, metadata)
        
    def test_similarity_pipeline(self):
        """Test pipeline with similarity retrieval strategy."""
        # Build pipeline
        pipeline_config = [
            {"component": "query_analyzer"},
            {"component": "personal_attributes"},
            {"component": "similarity_retrieval"},
        ]
        self.memory_manager.build_pipeline(pipeline_config)
        
        # Create query and context
        query = "Tell me about programming languages"
        query_embedding = self.embedding_model.encode(query)
        context = {
            "query_embedding": query_embedding,
            "memory": self.memory,
            "top_k": 3,
            "embedding_model": self.embedding_model
        }
        
        # Execute pipeline
        result_context = self.memory_manager.execute_pipeline(query, context)
        
        # Verify results
        self.assertIn("results", result_context)
        self.assertGreater(len(result_context["results"]), 0)
        
        # Verify that programming language information is retrieved
        language_found = False
        for result in result_context["results"]:
            if "programming language" in str(result.get("content", "")).lower():
                language_found = True
                break
                
        self.assertTrue(language_found, "Failed to retrieve programming language information")
        
    def test_hybrid_pipeline_with_processors(self):
        """Test pipeline with hybrid retrieval and all processors."""
        # Build pipeline
        pipeline_config = [
            {"component": "query_analyzer"},
            {"component": "personal_attributes"},
            {"component": "hybrid_retrieval"},
            {"component": "keyword_boost"},
            {"component": "coherence_check"},
            {"component": "adaptive_k"}
        ]
        self.memory_manager.build_pipeline(pipeline_config)
        
        # Create query and context
        query = "What's my favorite color?"
        query_embedding = self.embedding_model.encode(query)
        context = {
            "query_embedding": query_embedding,
            "memory": self.memory,
            "top_k": 3,
            "embedding_model": self.embedding_model
        }
        
        # Execute pipeline
        result_context = self.memory_manager.execute_pipeline(query, context)
        
        # Verify results
        self.assertIn("results", result_context)
        self.assertGreater(len(result_context["results"]), 0)
        
        # Verify personal attributes
        self.assertIn("personal_attributes", result_context)
        
        # Verify that color information is retrieved
        color_found = False
        for result in result_context["results"]:
            if "blue" in str(result.get("content", "")).lower():
                color_found = True
                break
                
        self.assertTrue(color_found, "Failed to retrieve color information")
        
    def test_temporal_pipeline(self):
        """Test pipeline with temporal retrieval strategy."""
        # Build pipeline
        pipeline_config = [
            {"component": "query_analyzer"},
            {"component": "personal_attributes"},
            {"component": "temporal_retrieval"},
        ]
        self.memory_manager.build_pipeline(pipeline_config)
        
        # Create query and context
        query = "What do I know?"
        query_embedding = self.embedding_model.encode(query)
        context = {
            "query_embedding": query_embedding,
            "memory": self.memory,
            "top_k": 3,
            "embedding_model": self.embedding_model
        }
        
        # Execute pipeline
        result_context = self.memory_manager.execute_pipeline(query, context)
        
        # Verify results
        self.assertIn("results", result_context)
        self.assertGreater(len(result_context["results"]), 0)
        
        # Verify that the most recent memory is first
        results = result_context["results"]
        if len(results) > 1:
            self.assertEqual(results[0]["memory_id"], len(self.memory.memory_metadata) - 1)


if __name__ == "__main__":
    unittest.main()
